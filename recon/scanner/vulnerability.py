import asyncio
import logging
import re
from typing import Dict, List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    import aiohttp

try:
    import aiohttp
except ImportError:
    aiohttp = None  # type: ignore

from scanner.base import BaseScanner

logger = logging.getLogger(__name__)

class VulnerabilityInfo:
    """Model for vulnerability information"""
    def __init__(self, cve_id, severity, score, description, references, published_date):
        self.cve_id = cve_id
        self.severity = severity
        self.score = score
        self.description = description
        self.references = references
        self.published_date = published_date

class VulnerabilityMapper(BaseScanner):
    """Map detected services to known CVEs"""
    
    def __init__(self, config, token_bucket):
        super().__init__(config, token_bucket)
        self.nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.cve_details_url = "https://cvedetails.com/cve"
        
    async def scan(self, assets: Dict[str, any]) -> Dict[str, List[VulnerabilityInfo]]:
        logger.info("[CVE] Starting vulnerability mapping")
        vuln_results = {}
        
        if self.dry_run:
            for ip in assets:
                dummy_vuln = VulnerabilityInfo(
                    cve_id="CVE-2023-12345",
                    severity="HIGH",
                    score=7.5,
                    description="Dummy vulnerability for testing",
                    references=["https://nvd.nist.gov"],
                    published_date="2023-01-01"
                )
                if hasattr(assets[ip], 'vulnerabilities'):
                    assets[ip].vulnerabilities = [dummy_vuln]
            return vuln_results
        
        sem = asyncio.Semaphore(5)  # Lower concurrency for API calls
        
        async def map_vulnerabilities_for_ip(ip: str, asset):
            async with sem:
                await self._pre_request()
                await self.token_bucket.consume()
                
                vulnerabilities = []
                
                # Extract service info
                services = self._extract_services(asset)
                
                for service in services:
                    try:
                        cves = await self._search_cves(service)
                        vulnerabilities.extend(cves)
                    except Exception as e:
                        logger.debug(f"CVE search failed for {service}: {e}")
                
                asset.vulnerabilities = vulnerabilities
                
                if vulnerabilities:
                    logger.info(f"[CVEâœ“] {ip} -> Found {len(vulnerabilities)} vulnerabilities")
                
                return ip, vulnerabilities
        
        tasks = [asyncio.create_task(map_vulnerabilities_for_ip(ip, asset)) for ip, asset in assets.items()]
        all_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for res in all_results:
            if not isinstance(res, Exception) and res:
                ip, vulns = res
                vuln_results[ip] = vulns
        
        return vuln_results
    
    def _extract_services(self, asset) -> List[Dict[str, str]]:
        """Extract service names and versions from asset"""
        services = []
        
        # From port scanning
        for port, port_info in asset.ports.items():
            service_name = port_info.get("service", "")
            if service_name and service_name != "unknown":
                services.append({
                    "name": service_name,
                    "version": port_info.get("version", ""),
                    "port": port
                })
        
        # From HTTP headers
        for http_key, http_info in asset.http_info.items():
            headers = http_info.get("headers", {})
            server = headers.get("Server", "")
            
            if server:
                # Parse server string for product/version
                # Example: "Apache/2.4.41 (Ubuntu)"
                match = re.match(r"([^/]+)/([^\s]+)", server)
                if match:
                    services.append({
                        "name": match.group(1),
                        "version": match.group(2),
                        "port": "http"
                    })
        
        return services
    
    async def _search_cves(self, service: Dict[str, str]) -> List[VulnerabilityInfo]:
        """Search for CVEs for a given service"""
        product_name = service.get("name", "").lower()
        version = service.get("version", "")
        
        if not product_name or aiohttp is None:
            return []
        
        # Use NVD API
        try:
            async with aiohttp.ClientSession() as session:
                # Build query
                params = {
                    "keywordSearch": f"{product_name} {version}",
                    "resultsPerPage": 10
                }
                
                if self.config.cve_api_key:
                    headers = {"apiKey": self.config.cve_api_key}
                else:
                    headers = {}
                
                async with session.get(
                    self.nvd_api_url,
                    params=params,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        return self._parse_nvd_response(data)
                    else:
                        logger.debug(f"NVD API returned {response.status}")
        
        except Exception as e:
            logger.debug(f"NVD API error: {e}")
        
        return []
    
    def _parse_nvd_response(self, data: Dict) -> List[VulnerabilityInfo]:
        """Parse NVD API response"""
        vulnerabilities = []
        
        try:
            cve_items = data.get("vulnerabilities", [])
            
            for item in cve_items[:5]:  # Limit to top 5
                cve = item.get("cve", {})
                cve_id = cve.get("id", "")
                
                # Get CVSS score
                metrics = cve.get("metrics", {})
                cvss_v3 = metrics.get("cvssMetricV31", [{}])[0]
                cvss_data = cvss_v3.get("cvssData", {})
                score = cvss_data.get("baseScore", 0.0)
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
                
                # Get description
                descriptions = cve.get("descriptions", [])
                desc = descriptions[0].get("value", "") if descriptions else ""
                
                # Get references
                references = []
                refs = cve.get("references", [])
                for ref in refs[:3]:
                    references.append(ref.get("url", ""))
                
                # Published date
                published = cve.get("published", "")
                
                vuln = VulnerabilityInfo(
                    cve_id=cve_id,
                    severity=severity,
                    score=score,
                    description=desc[:200],  # Truncate
                    references=references,
                    published_date=published
                )
                
                vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.debug(f"Failed to parse NVD response: {e}")
        
        return vulnerabilities
